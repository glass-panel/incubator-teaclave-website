"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[7868],{7249:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"sgx-sdk-docs/documents/sgxtime","title":"Acquiring Trusted timestamp from Intel ME in SGX enclave","description":"Intel provides Trusted Platform Service via Intel Management Engine. Part of the Intel SGX features depend on the trusted platform service, including the trusted timestamp service. We implemented sgx_tservice:","source":"@site/docs/sgx-sdk-docs/documents/sgxtime.md","sourceDirName":"sgx-sdk-docs/documents","slug":"/sgx-sdk-docs/documents/sgxtime","permalink":"/docs/sgx-sdk-docs/documents/sgxtime","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/sgx-sdk-docs/documents/sgxtime.md","tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/sgxtime"},"sidebar":"tutorialSidebar","previous":{"title":"Run Rust SGX Applications in Mesalock Linux","permalink":"/docs/sgx-sdk-docs/documents/sgx_in_mesalock_linux"},"next":{"title":"The World of Forked crates","permalink":"/docs/sgx-sdk-docs/documents/the-world-of-forked-crates"}}');var i=s(4848),r=s(8453);const o={permalink:"/sgx-sdk-docs/sgxtime"},l="Acquiring Trusted timestamp from Intel ME in SGX enclave",c={},a=[{value:"Run in docker",id:"run-in-docker",level:2},{value:"Run without docker",id:"run-without-docker",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"acquiring-trusted-timestamp-from-intel-me-in-sgx-enclave",children:"Acquiring Trusted timestamp from Intel ME in SGX enclave"})}),"\n",(0,i.jsxs)(n.p,{children:["Intel provides Trusted Platform Service via Intel Management Engine. Part of the Intel SGX features depend on the trusted platform service, including the trusted timestamp service. We implemented ",(0,i.jsx)(n.code,{children:"sgx_tservice::SgxTime"})," for this feature. To use it in Linux, the prerequisites are:"]}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/dev/mei0"})," must exist."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://github.com/intel/dynamic-application-loader-host-interface",children:"Dynamic Application Loader (DAL) Host Interface (aka JHI)"})," installed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://software.intel.com/en-us/sgx-sdk/download",children:"iclsClient"})," installed."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["The Ubuntu linux kernel would initiate Intel ME device during boot. Almost every Intel platform has Intel ME, but it may not be initiated properly. For ",(0,i.jsx)(n.a,{href:"https://github.com/ayeks/SGX-hardware/issues/24",children:"example"}),", a server of SuperServer 5019S-MR with v2.0b BIOS + v4.0.3.96 SPS could be initiated properly, while the other server with the same mother board and same BIOS version but v4.1.3.22 SPS couldn't."]}),"\n",(0,i.jsxs)(n.p,{children:["The JHI service usually runs as a daemon service process. Its ",(0,i.jsx)(n.a,{href:"https://github.com/intel/dynamic-application-loader-host-interface/blob/master/readme.md",children:"readme"})," is short and easy to read."]}),"\n",(0,i.jsxs)(n.p,{children:["The iclsClient could be downloaded from the ",(0,i.jsx)(n.a,{href:"https://software.intel.com/en-us/sgx-sdk/download",children:"Intel SGX's website"}),". Tozd's ",(0,i.jsx)(n.a,{href:"https://github.com/tozd/docker-sgx",children:"docker-sgx"})," provides a sample Dockerfile including the setup of iclsClient."]}),"\n",(0,i.jsxs)(n.p,{children:["One important thing is that the Intel SGX PSW has to be installed ",(0,i.jsx)(n.strong,{children:"after"})," the above three prerequisites has been satisfied. During the first time of PSW installation, the installer would try to do the provisioning for this platform, and this takes about one minute."]}),"\n",(0,i.jsxs)(n.p,{children:["We provide ",(0,i.jsx)(n.a,{href:"../samplecode/sgxtime",children:"sgxtime"})," code sample for demonstrating how to acquire trusted timestamp from Intel ME."]}),"\n",(0,i.jsx)(n.h2,{id:"run-in-docker",children:"Run in docker"}),"\n",(0,i.jsxs)(n.p,{children:["The dockerfile we provide contains an optional setup of icls. Due to the limitation of iclsClient, you need to acquire the installer from Intel and follow the instruction in ",(0,i.jsx)(n.a,{href:"../docker/Dockerfile",children:"Dockerfile"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"After downloaded the icls installer, please uncomment the icls related lines in Dockerfile and build the docker image by yourself."}),"\n",(0,i.jsx)(n.p,{children:"To run sgxtime in this docker image, first launch it using the following command:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"$ docker run -ti -v /path/to/sdk:/root/sgx \\\r\n             --device /dev/isgx \\\r\n             --device /dev/mei0 \\\r\n             rust-sgx-docker    # This name is identified during docker build\r\nroot@913e6a00c8d8:~#\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Then start the ",(0,i.jsx)(n.code,{children:"jhid"})," and ",(0,i.jsx)(n.code,{children:"aesm_service"})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@913e6a00c8d8:~# jhid -d\r\nroot@913e6a00c8d8:~# jhi[16]: --\x3e jhi start\r\njhi[16]: <-- jhi start\r\n\r\nroot@913e6a00c8d8:~# /opt/intel/sgxpsw/aesm/aesm_service\r\nroot@913e6a00c8d8:~# aesm_service[18]: [ADMIN]White List update requested\r\naesm_service[18]: The server sock is 0x55d3d2893940\r\njhi[16]: JHI service release prints are enabled\r\n\r\njhi[16]: Applet repository dir path: /var/lib/intel/dal/applet_repository\r\njhi[16]: Applets dir path: /var/lib/intel/dal/applets\r\naesm_service[18]: [ADMIN]White list update request successful for Version: 25\r\n\r\nroot@913e6a00c8d8:~#\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then build the code sample"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@913e6a00c8d8:~# cd sgx/samplecode/sgxtime/\r\nroot@913e6a00c8d8:~/sgx/samplecode/sgxtime# XARGO_SGX=1 make\r\nmake -C ./enclave/\r\nmake[1]: Entering directory '/root/sgx/samplecode/sgxtime/enclave'\r\ncargo build --release\r\n    Updating registry `https://github.com/rust-lang/crates.io-index`\r\n.........\r\n</EnclaveConfiguration>\r\ntcs_num 1, tcs_max_num 1, tcs_min_pool 1\r\nThe required memory is 2437120B.\r\nSucceed.\r\nSIGN =>  bin/enclave.signed.so\n"})}),"\n",(0,i.jsx)(n.p,{children:"Then run it. The first time would probably fail, but it only fails once."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"root@913e6a00c8d8:~/sgx/samplecode/sgxtime/bin# ./app\r\n[+] Home dir is /root\r\n[-] Open token file /root/enclave.token error! Will create one.\r\n[+] Saved updated launch token!\r\n[+] Init Enclave Successful 2!\r\naesm_service[18]: [ADMIN]Platform Services initializing\r\naesm_service[18]: [ADMIN]EPID Provisioning initiated\r\naesm_service[18]: [ADMIN]EPID Provisioning successful\r\naesm_service[18]: PCH EPID RL retrieval failure\r\nCannot create PSE session\r\nErr with SGX_ERROR_AE_SESSION_INVALID\r\nclose PSE session done\r\nHello world\r\n[+] sgx_time_sample success...\r\nroot@913e6a00c8d8:~/sgx/samplecode/sgxtime/bin# ./app\r\n[+] Home dir is /root\r\n[+] Open token file success!\r\n[+] Token file valid!\r\n[+] Init Enclave Successful 2!\r\naesm_service[18]: [ADMIN]Platform Services initializing\r\naesm_service[18]: [ADMIN]Platform Services initialized successfully\r\nCreate PSE session done\r\nOk with SgxTime { timestamp: 1420259903, source_nonce: [17, 101, 46, 174, 115, 133, 196, 251, 170, 218, 3, 21, 81, 92, 144, 241, 66, 38, 230, 186, 251, 193, 41, 246, 148, 131, 111, 126, 191, 105, 17, 33] }\r\nclose PSE session done\r\nHello world\r\n[+] sgx_time_sample success...\r\nroot@913e6a00c8d8:~/sgx/samplecode/sgxtime/bin# ./app\r\n[+] Home dir is /root\r\n[+] Open token file success!\r\n[+] Token file valid!\r\n[+] Init Enclave Successful 2!\r\nCreate PSE session done\r\nOk with SgxTime { timestamp: 1420259905, source_nonce: [17, 101, 46, 174, 115, 133, 196, 251, 170, 218, 3, 21, 81, 92, 144, 241, 66, 38, 230, 186, 251, 193, 41, 246, 148, 131, 111, 126, 191, 105, 17, 33] }\r\nclose PSE session done\r\nHello world\r\n[+] sgx_time_sample success...\n"})}),"\n",(0,i.jsx)(n.h2,{id:"run-without-docker",children:"Run without docker"}),"\n",(0,i.jsxs)(n.p,{children:["Follow the instruction of ",(0,i.jsx)(n.a,{href:"https://github.com/intel/dynamic-application-loader-host-interface",children:"JHI"})," first. Be sure to run ",(0,i.jsx)(n.code,{children:"systemctl enable jhi"})," to enable the service and then start it."]}),"\n",(0,i.jsxs)(n.p,{children:["Install iclsClient following Intel's setup ",(0,i.jsx)(n.a,{href:"https://download.01.org/intel-sgx/linux-2.0/docs/Intel_SGX_Installation_Guide_Linux_2.0_Open_Source.pdf",children:"instruction"}),". ",(0,i.jsx)(n.code,{children:"sudo ldconfig"})," may probably be needed after the installation."]}),"\n",(0,i.jsx)(n.p,{children:"Next, uninstall the current PSW (if installed) and reinstall it."}),"\n",(0,i.jsxs)(n.p,{children:["Now, ",(0,i.jsx)(n.code,{children:"sgxtime"})," should work."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>l});var t=s(6540);const i={},r=t.createContext(i);function o(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);