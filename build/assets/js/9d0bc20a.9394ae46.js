"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[7076],{8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var a=n(6540);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}},9904:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"mutual-attestation","title":"Mutual Attestation: Why and How","description":"The standard procedure to establish a secure and trusted communication channel","source":"@site/docs/mutual-attestation.md","sourceDirName":".","slug":"/mutual-attestation","permalink":"/docs/mutual-attestation","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/mutual-attestation.md","tags":[],"version":"current","frontMatter":{"permalink":"/docs/mutual-attestation"},"sidebar":"tutorialSidebar","previous":{"title":"Inference Task with TVM in Teaclave","permalink":"/docs/inference-with-tvm"},"next":{"title":"My First Function","permalink":"/docs/my-first-function"}}');var i=n(4848),s=n(8453);const r={permalink:"/docs/mutual-attestation"},o="Mutual Attestation: Why and How",c={},l=[{value:"Problem",id:"problem",level:2},{value:"Solution",id:"solution",level:2},{value:"In the Repository",id:"in-the-repository",level:2}];function d(e){const t={a:"a",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"mutual-attestation-why-and-how",children:"Mutual Attestation: Why and How"})}),"\n",(0,i.jsxs)(t.p,{children:["The standard procedure to establish a secure and trusted communication channel\r\nfrom a client to an enclave is through remote attestation. However, when the\r\nclient itself is also an enclave and ",(0,i.jsx)(t.em,{children:"mutual"})," trust between two enclaves is\r\nrequired, we need additional design and implementation effort. The Teaclave\r\nplatform consists of multiple enclave services and most of the\r\nenclave-to-enclave RPC communications need bidirectional authentication. This\r\ndocument entails the methodology and process of Teaclave's mutual enclave remote\r\nattestation."]}),"\n",(0,i.jsx)(t.h2,{id:"problem",children:"Problem"}),"\n",(0,i.jsx)(t.p,{children:"The identity of an enclave is defined through a pair of cryptographically secure\r\nhash values, i.e., MRSIGNER and MRENCLAVE. MRSIGNER indicates the builder of the\r\nenclave, thus shared by enclaves signed by the same party. MRENCLAVE is unique\r\nto each individual enclave. Teaclave assumes that users do not trust the\r\nsoftware builder, so verifying MRSIGNER is not enough. For each enclave service\r\nin Teaclave, it must strictly check the unique identity of the other enclaves it\r\ncommunicates to through MRENCLAVE."}),"\n",(0,i.jsx)(t.p,{children:"Since the SGX enclave trusts no outside input, the MRENCLAVE should be\r\nhard-coded into source files used for identity verification logic. Therefore,\r\nchanging the MRENCLAVE value an enclave tries to match against will change the\r\nMRENCLAVE of the enclave itself. When two enclaves want to remotely attest each\r\nother, it is impossible to decide which enclave is to be built first."}),"\n",(0,i.jsx)(t.h2,{id:"solution",children:"Solution"}),"\n",(0,i.jsxs)(t.p,{children:["Teaclave resolves this problem by relying on third-party auditors. We assume\r\nthat there will be several parties trusted by all participants of Teaclave's\r\ncomputation tasks (cloud platforms, data providers, and customers, etc). The\r\nsource code and binaries of Teaclave are audited by these trusted parties. Once\r\nthe auditors decided that Teaclave is secure, they sign and publish the\r\nidentities of audited enclaves. The ",(0,i.jsx)(t.em,{children:"public keys"})," of the auditors are\r\nhard-coded in Teaclave enclave source via build time configuration, while the\r\nenclave measures and their signatures are loaded from outside at runtime. Each\r\nenclave will verify that the enclave measures are indeed signed by the auditors\r\nbefore serving any requests."]}),"\n",(0,i.jsx)(t.h2,{id:"in-the-repository",children:"In the Repository"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.a,{href:"https://github.com/apache/incubator-teaclave/tree/master/config/keys",children:"keys"}),"\r\ndirectory in the source tree contain the key pairs of three fake auditing\r\nparties for PoC purposes. Private keys are also included to deliver a smooth\r\nbuild and test process. In production, builders of Teaclave should obtain the\r\npublic keys, enclave identities, and the signatures directly from the auditors."]})]})}function u(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);