"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[3132],{8453:(e,t,s)=>{s.d(t,{R:()=>d,x:()=>n});var o=s(6540);const a={},r=o.createContext(a);function d(e){const t=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function n(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:d(e.components),o.createElement(r.Provider,{value:t},e.children)}},9597:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>i,contentTitle:()=>n,default:()=>h,frontMatter:()=>d,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"teaclave-sgx-sdk/documents/the-world-of-forked-crates","title":"The World of Forked crates","description":"We created a \\"super repo\\" at dingelish/sgx-world, which includes all the forked repos as git submodules.","source":"@site/docs/teaclave-sgx-sdk/documents/the-world-of-forked-crates.md","sourceDirName":"teaclave-sgx-sdk/documents","slug":"/sgx-sdk-docs/the-world-of-forked-crates","permalink":"/sgx-sdk-docs/the-world-of-forked-crates","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/teaclave-sgx-sdk/documents/the-world-of-forked-crates.md","tags":[],"version":"current","frontMatter":{"permalink":"/sgx-sdk-docs/the-world-of-forked-crates","slug":"/sgx-sdk-docs/the-world-of-forked-crates"},"sidebar":"teaclave-sgx-sdk_sidebar","previous":{"title":"Public Cloud Rust SGX Development","permalink":"/sgx-sdk-docs/public-cloud-for-rust-sgx-dev"},"next":{"title":"Acquiring Trusted Timestamp from Intel ME in SGX enclave","permalink":"/sgx-sdk-docs/sgxtime"}}');var a=s(4848),r=s(8453);const d={permalink:"/sgx-sdk-docs/the-world-of-forked-crates",slug:"/sgx-sdk-docs/the-world-of-forked-crates"},n="The World of Forked crates",i={},c=[{value:"Tagging",id:"tagging",level:2},{value:"The World Map",id:"the-world-map",level:2},{value:"Security audit",id:"security-audit",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"the-world-of-forked-crates",children:"The World of Forked crates"})}),"\n",(0,a.jsxs)(t.p,{children:['We created a "super repo" at ',(0,a.jsx)(t.a,{href:"https://github.com/dingelish/sgx-world",children:"dingelish/sgx-world"}),", which includes all the forked repos as git submodules."]}),"\n",(0,a.jsxs)(t.p,{children:['We created a "dumb crate" ',(0,a.jsx)(t.a,{href:"https://github.com/dingelish/sgx-world/tree/master/dumb-all",children:"dumb-all"})," to help us maintain the world of forked crates. Each dependency of dumb-all is a valid crate in Rust-SGX ecosystem. The enabled feature set is likely to be the universe of supported feature set. Exceptions exist in a couple of crates, where there are conflict features."]}),"\n",(0,a.jsx)(t.p,{children:"Generally speaking, to use a forked crate, simply use the following statement:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-toml",children:'wasmi = { git = "https://github.com/mesalock-linux/wasmi-sgx" }\n'})}),"\n",(0,a.jsx)(t.p,{children:"No need to config the branch in most cases. Only a few of the forked crates use specific branches."}),"\n",(0,a.jsx)(t.h2,{id:"tagging",children:"Tagging"}),"\n",(0,a.jsxs)(t.p,{children:["As of today, Oct 23 2019, cargo still has problem on git dependencies. The issue is ",(0,a.jsx)(t.a,{href:"https://github.com/rust-lang/cargo/issues/7497",children:"cargo #7497"}),". It leads to a dependency hell if the Cargo.toml looks like:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-toml",children:'foo = { git = "https://github.com/..." }\nfoo = { git = "https://github.com/...", rev = "deadbeaf" }\nfoo = { git = "https://github.com/...", tag = "deadbeaf" }\n'})}),"\n",(0,a.jsxs)(t.p,{children:["These three foos are all valid, but different from each other in compilation. Assume that crate ",(0,a.jsx)(t.code,{children:"bar"})," depends on foo with the first one, and ",(0,a.jsx)(t.code,{children:"haa"})," depends on foo with the second one, then the dependency tree is going to mess up. So this is the reason that almost all forked crates are tagged with ",(0,a.jsx)(t.code,{children:"sgx_1.0.9"})," but the cross references are not using that tag."]}),"\n",(0,a.jsx)(t.p,{children:"One potential fix is a tool to fix Cargo.lock and remove the redundant crates. I've done this successfully by manually dedup Cargo.lock according to the hash value instead of URI. Maybe we can automate this later\""}),"\n",(0,a.jsx)(t.h2,{id:"the-world-map",children:"The World Map"}),"\n",(0,a.jsxs)(t.p,{children:["Generated by ",(0,a.jsx)(t.code,{children:"cargo deps"})," on dumb-all."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{src:"https://github.com/dingelish/sgx-world/raw/master/dumb-all/world.png",alt:"world map"})}),"\n",(0,a.jsx)(t.h2,{id:"security-audit",children:"Security audit"}),"\n",(0,a.jsxs)(t.p,{children:["We use ",(0,a.jsx)(t.a,{href:"https://github.com/RustSec/cargo-audit",children:(0,a.jsx)(t.code,{children:"cargo-audit"})})," to automatically check for known vulnerabilities. And the pipeline has been added to CI which runs nightly. We'll update immediately once we find a security issue by ",(0,a.jsx)(t.code,{children:"cargo-audit"}),". Thanks to @tarcieri for this fantastic tool!"]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);