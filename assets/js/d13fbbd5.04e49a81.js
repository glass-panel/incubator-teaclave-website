"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[6232],{807:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>h,frontMatter:()=>c,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"access-control","title":"Access Control in Teaclave","description":"Access control in multi-party computation, by its nature, is set-centric. Unlike","source":"@site/docs/access-control.md","sourceDirName":".","slug":"/access-control","permalink":"/docs/access-control","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/access-control.md","tags":[],"version":"current","frontMatter":{"permalink":"/docs/access-control"},"sidebar":"tutorialSidebar","previous":{"title":"Teaclave Documentation","permalink":"/docs/"},"next":{"title":"Adding Executors","permalink":"/docs/adding-executors"}}');var t=a(4848),r=a(8453);const c={permalink:"/docs/access-control"},i="Access Control in Teaclave",o={},d=[{value:"Model",id:"model",level:2},{value:"request",id:"request",level:3},{value:"term",id:"term",level:3},{value:"matcher",id:"matcher",level:3},{value:"Implementation",id:"implementation",level:2}];function l(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"access-control-in-teaclave",children:"Access Control in Teaclave"})}),"\n",(0,t.jsx)(n.p,{children:"Access control in multi-party computation, by its nature, is set-centric. Unlike\r\nin traditional settings where only one entity, group, or role is involved in an\r\naction, in multi-party computation tasks an access is approved or denied by\r\ncombining the decisions of all stakeholders. Ownership is also set-like, because\r\nthe result of a joint computation task very likely belongs to all parties that\r\nhave provided data."}),"\n",(0,t.jsx)(n.p,{children:"We found that access control models in conventional systems like RBAC and ABAC\r\nare not powerful enough to govern data usages in Teaclave. Therefore, we\r\ninvented our own access control model and mechanism."}),"\n",(0,t.jsx)(n.h2,{id:"model",children:"Model"}),"\n",(0,t.jsxs)(n.p,{children:["The access control model of Teaclave is configured through the file\r\n",(0,t.jsx)(n.a,{href:"https://github.com/apache/incubator-teaclave/blob/master/services/access_control/model.conf",children:"model.conf"}),".\r\nThe file has three sections:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"requests"}),"\n",(0,t.jsx)(n.li,{children:"terms"}),"\n",(0,t.jsx)(n.li,{children:"matchers"}),"\n"]}),"\n",(0,t.jsxs)(n.p,{children:["Before diving into the details about how our access control model works, we\r\nrecommend readers learn about ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Logic_programming",children:"logic programming"}),"\r\nfirst, because our\r\nmodel configuration language is actually a home-baked tiny logic programming\r\nlanguage."]}),"\n",(0,t.jsx)(n.h3,{id:"request",children:"request"}),"\n",(0,t.jsx)(n.p,{children:'A request is a query that should be answered by the access control service. The\r\nresponse is either "approved" or "denied." A request is defined as a tuple of\r\nany arity. For example,'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[requests]\r\ntask_access_data = task, data\n"})}),"\n",(0,t.jsxs)(n.p,{children:["defines a request called ",(0,t.jsx)(n.code,{children:"task_access_data"})," which contains two fields named\r\n",(0,t.jsx)(n.code,{children:"task"})," and ",(0,t.jsx)(n.code,{children:"data"}),". This request can mean a task with the id ",(0,t.jsx)(n.code,{children:"task"})," wants to\r\naccess a piece of data hosted by Teaclave whose id is ",(0,t.jsx)(n.code,{children:"data"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"term",children:"term"}),"\n",(0,t.jsx)(n.p,{children:"Terms are relations over certain domains. Each term can be viewed as a table\r\nstoring facts about the entities revelant to the access control logic. For\r\nexample,"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[terms]\r\ndata_owner = data, usr\r\ntask_participant = task, usr\n"})}),"\n",(0,t.jsxs)(n.p,{children:["For the ",(0,t.jsx)(n.code,{children:"task_access_data"})," request, there are three relevant domains: ",(0,t.jsx)(n.code,{children:"data"}),",\r\n",(0,t.jsx)(n.code,{children:"usr"}),", and ",(0,t.jsx)(n.code,{children:"task"}),". Furthermore, two relations are required by Teaclave to make\r\na decision, which are"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"data_owner"})," relation over (",(0,t.jsx)(n.code,{children:"data"})," X ",(0,t.jsx)(n.code,{children:"usr"}),"), denoting which user owns\r\na piece of data."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"task_participant"})," relation over (",(0,t.jsx)(n.code,{children:"task"})," X ",(0,t.jsx)(n.code,{children:"usr"}),"), denoting which\r\nusers are the participants of a joint computation task."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"An instance of the database describing the two terms could be"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"data_owner data_1, usr_1\r\ndata_owner data_2, usr_1\r\ndata_owner data_2, usr_2\r\n\r\ntask_participant task_1 usr_1\r\ntask_participant task_1 usr_2\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The facts stored in this database instance indicate that ",(0,t.jsx)(n.code,{children:"data_1"})," is owned\r\nexclusively by ",(0,t.jsx)(n.code,{children:"usr_1"}),", while ",(0,t.jsx)(n.code,{children:"data_2"})," is owned by ",(0,t.jsx)(n.code,{children:"usr_1"})," and ",(0,t.jsx)(n.code,{children:"usr_2"}),"\r\ntogether. The facts also indicates that ",(0,t.jsx)(n.code,{children:"task_1"})," has two participants, i.e.,\r\n",(0,t.jsx)(n.code,{children:"usr_1"})," and ",(0,t.jsx)(n.code,{children:"usr_2"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"matcher",children:"matcher"}),"\n",(0,t.jsxs)(n.p,{children:["The core logic used by Teaclave to resolve a request is defined as a matcher.\r\nWe define the matcher for ",(0,t.jsx)(n.code,{children:"task_access_data"})," request as the following"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"[matcher]\r\ntask_access_data = data_owner(task_access_data.data, _) <= task_participant(task_access_data.task, _)\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"data_owner(task_access_data.data, _)"})," and\r\n",(0,t.jsx)(n.code,{children:"task_participant(task_access_data.task, _)"})," are term queries. The return value\r\nof ",(0,t.jsx)(n.code,{children:"data_owner(task_access_data.data, _)"})," is a subset of the ",(0,t.jsx)(n.code,{children:"usr"})," domain,\r\nwhere each value ",(0,t.jsx)(n.code,{children:"u"})," in the fact meets the condition that"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"data_owner task_access_data.data u\n"})}),"\n",(0,t.jsxs)(n.p,{children:["is in the terms database. ",(0,t.jsx)(n.code,{children:"_"})," is called the query wild card and ",(0,t.jsx)(n.code,{children:"<="})," is the\r\nsubset operator. Therefore, the matcher basically means that, ",(0,t.jsxs)(n.em,{children:["the request for\r\n",(0,t.jsx)(n.code,{children:"task"})," to access ",(0,t.jsx)(n.code,{children:"data"})," is approved only if all owners of ",(0,t.jsx)(n.code,{children:"data"})," are have\r\narticipated in ",(0,t.jsx)(n.code,{children:"task"})]}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,t.jsx)(n.p,{children:"The access control module of Teaclave is implemented as a standalone service.\r\nOther components should send RPC requests to the service and get access control\r\ndecisions as RPC responses."}),"\n",(0,t.jsx)(n.p,{children:"The model configuration parser and request resolution engine are written in\r\nPython, powered by MesaPy. The access control service of Teaclave is a nice\r\nshowcase of what MesaPy is capable of."}),"\n",(0,t.jsx)(n.p,{children:"The implementation is purely experimental at this point. The performance is not\r\noptimized and the engine is likely not robust enough to avoid crashes while\r\ndealing with badly shaped requests. Contributions are welcome!"})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>c,x:()=>i});var s=a(6540);const t={},r=s.createContext(t);function c(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);