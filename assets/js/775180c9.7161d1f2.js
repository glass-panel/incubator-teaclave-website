"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[3711],{6414:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"trustzone-sdk-docs/docs/debugging-optee-ta","title":"Debugging OP-TEE TA","description":"When developing applications, it is inevitable that there will be a need for","source":"@site/docs/trustzone-sdk-docs/docs/debugging-optee-ta.md","sourceDirName":"trustzone-sdk-docs/docs","slug":"/trustzone-sdk-docs/docs/debugging-optee-ta","permalink":"/docs/trustzone-sdk-docs/docs/debugging-optee-ta","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/trustzone-sdk-docs/docs/debugging-optee-ta.md","tags":[],"version":"current","frontMatter":{"permalink":"/trustzone-sdk-docs/debugging-optee-ta.md"},"sidebar":"tutorialSidebar","previous":{"title":"Building Rust CA as Android ELF","permalink":"/docs/trustzone-sdk-docs/docs/building-rust-ca-as-android-elf"},"next":{"title":"\ud83d\ude80 Quick Start For QEMU Emulation","permalink":"/docs/trustzone-sdk-docs/docs/emulate-and-dev-in-docker"}}');var r=t(4848),s=t(8453);const a={permalink:"/trustzone-sdk-docs/debugging-optee-ta.md"},i="Debugging OP-TEE TA",d={},c=[];function l(e){const n={a:"a",code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"debugging-op-tee-ta",children:"Debugging OP-TEE TA"})}),"\n",(0,r.jsxs)(n.p,{children:["When developing applications, it is inevitable that there will be a need for\r\ndebugging. This tutorial introduces how to configure the debug environment in\r\nOP-TEE enabled QEMU environment. You may also check\r\n",(0,r.jsx)(n.a,{href:"https://optee.readthedocs.io/en/latest/building/devices/qemu.html",children:"OP-TEE documentation"}),"\r\nfor more information about running QEMU for Arm v8."]}),"\n",(0,r.jsxs)(n.p,{children:["To debug TEE core running QEMU with GDB, it is necessary to disable TEE ASLR with\r\n",(0,r.jsx)(n.code,{children:"CFG_CORE_ASLR ?= n"})," in ",(0,r.jsx)(n.code,{children:"OP-TEE/optee_os/mk/config.mk"}),". Note that you need to\r\nrecompile QEMU with ",(0,r.jsx)(n.code,{children:"make run"})," again. You can also choose to add the compilation\r\ninformation directly at compile time."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"$ make run CFG_CORE_ASLR=n\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Since we will debug the TA remotely with a ",(0,r.jsx)(n.code,{children:"gdb"})," server, please also add the\r\n",(0,r.jsx)(n.code,{children:"GDBSERVER=y"})," flag when compiling QEMU."]}),"\n",(0,r.jsxs)(n.p,{children:["To debug a TA, you need to first start a gdb on the host machine. Then run\r\n",(0,r.jsx)(n.code,{children:"target remote :1234"})," to connect to the remote QEMU GDB server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:'$ ./path/to/qemu-v8-project/out-br/host/bin/aarch64-buildroot-linux-gnu-gdb\r\n(gdb) target remote :1234\r\nRemote debugging using :1234\r\nwarning: No executable has been specified and target does not support\r\ndetermining executable automatically.  Try using the "file" command.\r\n0xffffb30b00ea12b4 in ?? ()\n'})}),"\n",(0,r.jsx)(n.p,{children:"Next, in the GDB console, load the symbol table of the TEE core library."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"(gdb) symbol-file /path/to/qemu-v8-project/optee_os/out/arm/core/tee.elf\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Taking ",(0,r.jsx)(n.code,{children:"hello_world-rs"})," as an example, you can get the start address of the text\r\nsection from the log in the secure world console, which is 0x40014000."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"D/LD:  ldelf:168 ELF (133af0ca-bdab-11eb-9130-43bf7873bf67) at 0x40014000\n"})}),"\n",(0,r.jsx)(n.p,{children:"Then, you can load symbols from TA file (in debug build) to the address."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"(gdb) add-symbol-file /path/to/examples/hello_world-rs/ta/target/aarch64-unknown-linux-gnu/debug/ta 0x40014000\n"})}),"\n",(0,r.jsx)(n.p,{children:"Now, you can add breakpoints according to your own needs in the corresponding\r\nfunctions or addresses."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:"(gdb) b invoke_command\r\nBreakpoint 2 at 0xe11bb08: invoke_command. (6 locations)\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Last, initiate the boot. You can execute ",(0,r.jsx)(n.code,{children:"hello_world-rs"})," in the normal world\r\nconsole, and will see that the breakpoint we set was hit."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-sh",children:'(gdb) c\r\nContinuing.\r\n[Switching to Thread 1.2]\r\n\r\nThread 2 hit Breakpoint 2, ta::invoke_command (cmd_id=0, params=0x4010ff00) at src/main.rs:50\r\n50\t    trace_println!("[+] TA invoke command");\n'})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var o=t(6540);const r={},s=o.createContext(r);function a(e){const n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);