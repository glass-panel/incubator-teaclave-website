"use strict";(self.webpackChunkapache_teaclave_incubating=self.webpackChunkapache_teaclave_incubating||[]).push([[6522],{5374:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>d,metadata:()=>a,toc:()=>o});const a=JSON.parse('{"id":"teaclave/third_party/README","title":"Third-Party Dependency Vendoring","description":"For Teaclave, since all SGX/enclave dependencies are part of trusted computing base (TCB),","source":"@site/docs/teaclave/third_party/README.md","sourceDirName":"teaclave/third_party","slug":"/docs/codebase/third-party","permalink":"/docs/codebase/third-party","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/incubator-teaclave-website/tree/master/sgx-sdk-api-docs/docs/teaclave/third_party/README.md","tags":[],"version":"current","frontMatter":{"permalink":"/docs/codebase/third-party","slug":"/docs/codebase/third-party"},"sidebar":"teaclave_sidebar","previous":{"title":"Test Harness and Test Cases","permalink":"/docs/codebase/tests"},"next":{"title":"Tools","permalink":"/docs/codebase/tools"}}');var r=n(4848),s=n(8453);const d={permalink:"/docs/codebase/third-party",slug:"/docs/codebase/third-party"},i="Third-Party Dependency Vendoring",c={},o=[];function l(e){const t={a:"a",code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"third-party-dependency-vendoring",children:"Third-Party Dependency Vendoring"})}),"\n",(0,r.jsxs)(t.p,{children:["For Teaclave, since all SGX/enclave dependencies are part of trusted computing base (TCB),\nin order to ease auditing, ensure product stability, as well as reduce the\npossibility of the ",(0,r.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Supply_chain_attack",children:"supply chain attack"}),",\nall TEE dependencies should be vendored. Then during the build process, both the\nuntrusted (i.e., the app part) and trusted components (i.e., the enclave part)\nwill only consume packages from this designated repository and will not\ndownload any code from external package registry such as\n",(0,r.jsx)(t.a,{href:"https://crates.io",children:"crates.io"}),". The vendoring of Rust crates are not done here\nfor development ease but are recommended for production use."]}),"\n",(0,r.jsx)(t.p,{children:"Basically, we have these submodules:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"rust-sgx-sdk"}),": Teaclave SGX SDK for standard libraries and Rust bindings of\nSGX libraries."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"webassembly-micro-runtime"}),": A sandboxed runtime to execute(interpret)\nWebAssembly bytecode."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>d,x:()=>i});var a=n(6540);const r={},s=a.createContext(r);function d(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:d(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);