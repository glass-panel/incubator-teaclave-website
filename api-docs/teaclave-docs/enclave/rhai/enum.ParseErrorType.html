<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Error encountered when parsing a script."><meta name="keywords" content="rust, rustlang, rust-lang, ParseErrorType"><title>ParseErrorType in rhai - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="sidebar-items.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../rhai/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../rhai/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">ParseErrorType</a></h2><div class="sidebar-elems"><section><h3><a href="#variants">Variants</a></h3><ul class="block"><li><a href="#variant.AssignmentToConstant">AssignmentToConstant</a></li><li><a href="#variant.AssignmentToInvalidLHS">AssignmentToInvalidLHS</a></li><li><a href="#variant.BadInput">BadInput</a></li><li><a href="#variant.DuplicatedProperty">DuplicatedProperty</a></li><li><a href="#variant.DuplicatedSwitchCase">DuplicatedSwitchCase</a></li><li><a href="#variant.DuplicatedVariable">DuplicatedVariable</a></li><li><a href="#variant.ExprExpected">ExprExpected</a></li><li><a href="#variant.ExprTooDeep">ExprTooDeep</a></li><li><a href="#variant.FnDuplicatedDefinition">FnDuplicatedDefinition</a></li><li><a href="#variant.FnDuplicatedParam">FnDuplicatedParam</a></li><li><a href="#variant.FnMissingBody">FnMissingBody</a></li><li><a href="#variant.FnMissingName">FnMissingName</a></li><li><a href="#variant.FnMissingParams">FnMissingParams</a></li><li><a href="#variant.ForbiddenVariable">ForbiddenVariable</a></li><li><a href="#variant.LiteralTooLarge">LiteralTooLarge</a></li><li><a href="#variant.LoopBreak">LoopBreak</a></li><li><a href="#variant.MalformedCallExpr">MalformedCallExpr</a></li><li><a href="#variant.MalformedCapture">MalformedCapture</a></li><li><a href="#variant.MalformedInExpr">MalformedInExpr</a></li><li><a href="#variant.MalformedIndexExpr">MalformedIndexExpr</a></li><li><a href="#variant.MismatchedType">MismatchedType</a></li><li><a href="#variant.MissingSymbol">MissingSymbol</a></li><li><a href="#variant.MissingToken">MissingToken</a></li><li><a href="#variant.ModuleUndefined">ModuleUndefined</a></li><li><a href="#variant.PropertyExpected">PropertyExpected</a></li><li><a href="#variant.Reserved">Reserved</a></li><li><a href="#variant.UnexpectedEOF">UnexpectedEOF</a></li><li><a href="#variant.UnknownOperator">UnknownOperator</a></li><li><a href="#variant.VariableExists">VariableExists</a></li><li><a href="#variant.VariableExpected">VariableExpected</a></li><li><a href="#variant.VariableUndefined">VariableUndefined</a></li><li><a href="#variant.WrongDocComment">WrongDocComment</a></li><li><a href="#variant.WrongExport">WrongExport</a></li><li><a href="#variant.WrongFnDefinition">WrongFnDefinition</a></li><li><a href="#variant.WrongSwitchCaseCondition">WrongSwitchCaseCondition</a></li><li><a href="#variant.WrongSwitchDefaultCase">WrongSwitchDefaultCase</a></li><li><a href="#variant.WrongSwitchIntegerCase">WrongSwitchIntegerCase</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block"><li><a href="#impl-Clone-for-ParseErrorType">Clone</a></li><li><a href="#impl-Debug-for-ParseErrorType">Debug</a></li><li><a href="#impl-Display-for-ParseErrorType">Display</a></li><li><a href="#impl-Eq-for-ParseErrorType">Eq</a></li><li><a href="#impl-From%3CLexError%3E-for-ParseErrorType">From&lt;LexError&gt;</a></li><li><a href="#impl-From%3CParseErrorType%3E-for-Box%3CEvalAltResult%3E">From&lt;ParseErrorType&gt;</a></li><li><a href="#impl-From%3CParseErrorType%3E-for-EvalAltResult">From&lt;ParseErrorType&gt;</a></li><li><a href="#impl-Hash-for-ParseErrorType">Hash</a></li><li><a href="#impl-PartialEq%3CParseErrorType%3E-for-ParseErrorType">PartialEq&lt;ParseErrorType&gt;</a></li><li><a href="#impl-StructuralEq-for-ParseErrorType">StructuralEq</a></li><li><a href="#impl-StructuralPartialEq-for-ParseErrorType">StructuralPartialEq</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block"><li><a href="#impl-RefUnwindSafe-for-ParseErrorType">RefUnwindSafe</a></li><li><a href="#impl-Send-for-ParseErrorType">Send</a></li><li><a href="#impl-Sync-for-ParseErrorType">Sync</a></li><li><a href="#impl-Unpin-for-ParseErrorType">Unpin</a></li><li><a href="#impl-UnwindSafe-for-ParseErrorType">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block"><li><a href="#impl-Any-for-ParseErrorType">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-ParseErrorType">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-ParseErrorType">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-ParseErrorType">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-ParseErrorType">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-ParseErrorType">ToOwned</a></li><li><a href="#impl-ToString-for-ParseErrorType">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-ParseErrorType">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-ParseErrorType">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In rhai</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Enum <a href="index.html">rhai</a>::<wbr><a class="enum" href="#">ParseErrorType</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/rhai/types/parse_error.rs.html#73-168">source</a> Â· <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="item-decl"><pre class="rust enum"><code>#[non_exhaustive]
pub enum ParseErrorType {
<details class="rustdoc-toggle type-contents-toggle"><summary class="hideme"><span>Show 37 variants</span></summary>    UnexpectedEOF,
    BadInput(<a class="enum" href="enum.LexError.html" title="enum rhai::LexError">LexError</a>),
    UnknownOperator(String),
    MissingToken(String,&nbsp;String),
    MissingSymbol(String),
    MalformedCallExpr(String),
    MalformedIndexExpr(String),
    MalformedInExpr(String),
    MalformedCapture(String),
    DuplicatedProperty(String),
    DuplicatedSwitchCase,
    DuplicatedVariable(String),
    WrongSwitchIntegerCase,
    WrongSwitchDefaultCase,
    WrongSwitchCaseCondition,
    PropertyExpected,
    VariableExpected,
    ForbiddenVariable(String),
    Reserved(String),
    MismatchedType(String,&nbsp;String),
    ExprExpected(String),
    WrongDocComment,
    WrongFnDefinition,
    FnDuplicatedDefinition(String,&nbsp;usize),
    FnMissingName,
    FnMissingParams(String),
    FnDuplicatedParam(String,&nbsp;String),
    FnMissingBody(String),
    WrongExport,
    AssignmentToConstant(String),
    AssignmentToInvalidLHS(String),
    VariableExists(String),
    VariableUndefined(String),
    ModuleUndefined(String),
    ExprTooDeep,
    LiteralTooLarge(String,&nbsp;usize),
    LoopBreak,
</details>}</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Error encountered when parsing a script.</p>
<p>Some errors never appear when certain features are turned on.
They still exist so that the application can turn features on and off without going through
massive code changes to remove/add back enum variants in match statements.</p>
</div></details><h2 id="variants" class="variants small-section-header">Variants (Non-exhaustive)<a href="#variants" class="anchor"></a></h2><details class="rustdoc-toggle non-exhaustive"><summary class="hideme"><span>This enum is marked as non-exhaustive</span></summary><div class="docblock">Non-exhaustive enums could have additional variants added in future. Therefore, when matching against variants of non-exhaustive enums, an extra wildcard arm must be added to account for any future variants.</div></details><h3 id="variant.UnexpectedEOF" class="variant small-section-header"><a href="#variant.UnexpectedEOF" class="anchor field"></a><code>UnexpectedEOF</code></h3><div class="docblock"><p>The script ends prematurely.</p>
</div><h3 id="variant.BadInput" class="variant small-section-header"><a href="#variant.BadInput" class="anchor field"></a><code>BadInput(<a class="enum" href="enum.LexError.html" title="enum rhai::LexError">LexError</a>)</code></h3><div class="docblock"><p>Error in the script text. Wrapped value is the lex error.</p>
</div><h3 id="variant.UnknownOperator" class="variant small-section-header"><a href="#variant.UnknownOperator" class="anchor field"></a><code>UnknownOperator(String)</code></h3><div class="docblock"><p>An unknown operator is encountered. Wrapped value is the operator.</p>
</div><h3 id="variant.MissingToken" class="variant small-section-header"><a href="#variant.MissingToken" class="anchor field"></a><code>MissingToken(String,&nbsp;String)</code></h3><div class="docblock"><p>Expecting a particular token but not finding one. Wrapped values are the token and description.</p>
</div><h3 id="variant.MissingSymbol" class="variant small-section-header"><a href="#variant.MissingSymbol" class="anchor field"></a><code>MissingSymbol(String)</code></h3><div class="docblock"><p>Expecting a particular symbol but not finding one. Wrapped value is the description.</p>
</div><h3 id="variant.MalformedCallExpr" class="variant small-section-header"><a href="#variant.MalformedCallExpr" class="anchor field"></a><code>MalformedCallExpr(String)</code></h3><div class="docblock"><p>An expression in function call arguments <code>()</code> has syntax error. Wrapped value is the error
description (if any).</p>
</div><h3 id="variant.MalformedIndexExpr" class="variant small-section-header"><a href="#variant.MalformedIndexExpr" class="anchor field"></a><code>MalformedIndexExpr(String)</code></h3><div class="docblock"><p>An expression in indexing brackets <code>[]</code> has syntax error. Wrapped value is the error
description (if any).</p>
</div><h3 id="variant.MalformedInExpr" class="variant small-section-header"><a href="#variant.MalformedInExpr" class="anchor field"></a><code>MalformedInExpr(String)</code></h3><div class="docblock"><p>An expression in an <code>in</code> expression has syntax error. Wrapped value is the error description (if any).</p>
</div><h3 id="variant.MalformedCapture" class="variant small-section-header"><a href="#variant.MalformedCapture" class="anchor field"></a><code>MalformedCapture(String)</code></h3><div class="docblock"><p>A capturing  has syntax error. Wrapped value is the error description (if any).</p>
</div><h3 id="variant.DuplicatedProperty" class="variant small-section-header"><a href="#variant.DuplicatedProperty" class="anchor field"></a><code>DuplicatedProperty(String)</code></h3><div class="docblock"><p>A map definition has duplicated property names. Wrapped value is the property name.</p>
</div><h3 id="variant.DuplicatedSwitchCase" class="variant small-section-header"><a href="#variant.DuplicatedSwitchCase" class="anchor field"></a><code>DuplicatedSwitchCase</code></h3><span class="item-info"><div class="stab deprecated"><span class="emoji">ðŸ‘Ž</span><span>Deprecated since 1.9.0: This error variant is deprecated. It never occurs and will be removed in the next major version.</span></div></span><div class="docblock"><p>A <code>switch</code> case is duplicated.</p>
<h4 id="deprecated"><a href="#deprecated">Deprecated</a></h4>
<p>This error variant is deprecated. It never occurs and will be removed in the next major version.</p>
</div><h3 id="variant.DuplicatedVariable" class="variant small-section-header"><a href="#variant.DuplicatedVariable" class="anchor field"></a><code>DuplicatedVariable(String)</code></h3><div class="docblock"><p>A variable name is duplicated. Wrapped value is the variable name.</p>
</div><h3 id="variant.WrongSwitchIntegerCase" class="variant small-section-header"><a href="#variant.WrongSwitchIntegerCase" class="anchor field"></a><code>WrongSwitchIntegerCase</code></h3><div class="docblock"><p>A numeric case of a <code>switch</code> statement is in an appropriate place.</p>
</div><h3 id="variant.WrongSwitchDefaultCase" class="variant small-section-header"><a href="#variant.WrongSwitchDefaultCase" class="anchor field"></a><code>WrongSwitchDefaultCase</code></h3><div class="docblock"><p>The default case of a <code>switch</code> statement is in an appropriate place.</p>
</div><h3 id="variant.WrongSwitchCaseCondition" class="variant small-section-header"><a href="#variant.WrongSwitchCaseCondition" class="anchor field"></a><code>WrongSwitchCaseCondition</code></h3><div class="docblock"><p>The case condition of a <code>switch</code> statement is not appropriate.</p>
</div><h3 id="variant.PropertyExpected" class="variant small-section-header"><a href="#variant.PropertyExpected" class="anchor field"></a><code>PropertyExpected</code></h3><div class="docblock"><p>Missing a property name for custom types and maps.</p>
</div><h3 id="variant.VariableExpected" class="variant small-section-header"><a href="#variant.VariableExpected" class="anchor field"></a><code>VariableExpected</code></h3><div class="docblock"><p>Missing a variable name after the <code>let</code>, <code>const</code>, <code>for</code> or <code>catch</code> keywords.</p>
</div><h3 id="variant.ForbiddenVariable" class="variant small-section-header"><a href="#variant.ForbiddenVariable" class="anchor field"></a><code>ForbiddenVariable(String)</code></h3><div class="docblock"><p>Forbidden variable name.  Wrapped value is the variable name.</p>
</div><h3 id="variant.Reserved" class="variant small-section-header"><a href="#variant.Reserved" class="anchor field"></a><code>Reserved(String)</code></h3><div class="docblock"><p>An identifier is a reserved symbol.</p>
</div><h3 id="variant.MismatchedType" class="variant small-section-header"><a href="#variant.MismatchedType" class="anchor field"></a><code>MismatchedType(String,&nbsp;String)</code></h3><div class="docblock"><p>An expression is of the wrong type.
Wrapped values are the type requested and type of the actual result.</p>
</div><h3 id="variant.ExprExpected" class="variant small-section-header"><a href="#variant.ExprExpected" class="anchor field"></a><code>ExprExpected(String)</code></h3><div class="docblock"><p>Missing an expression. Wrapped value is the expression type.</p>
</div><h3 id="variant.WrongDocComment" class="variant small-section-header"><a href="#variant.WrongDocComment" class="anchor field"></a><code>WrongDocComment</code></h3><div class="docblock"><p>Defining a doc-comment in an appropriate place (e.g. not at global level).</p>
</div><h3 id="variant.WrongFnDefinition" class="variant small-section-header"><a href="#variant.WrongFnDefinition" class="anchor field"></a><code>WrongFnDefinition</code></h3><div class="docblock"><p>Defining a function <code>fn</code> in an appropriate place (e.g. inside another function).</p>
</div><h3 id="variant.FnDuplicatedDefinition" class="variant small-section-header"><a href="#variant.FnDuplicatedDefinition" class="anchor field"></a><code>FnDuplicatedDefinition(String,&nbsp;usize)</code></h3><div class="docblock"><p>Defining a function with a name that conflicts with an existing function.
Wrapped values are the function name and number of parameters.</p>
</div><h3 id="variant.FnMissingName" class="variant small-section-header"><a href="#variant.FnMissingName" class="anchor field"></a><code>FnMissingName</code></h3><div class="docblock"><p>Missing a function name after the <code>fn</code> keyword.</p>
</div><h3 id="variant.FnMissingParams" class="variant small-section-header"><a href="#variant.FnMissingParams" class="anchor field"></a><code>FnMissingParams(String)</code></h3><div class="docblock"><p>A function definition is missing the parameters list. Wrapped value is the function name.</p>
</div><h3 id="variant.FnDuplicatedParam" class="variant small-section-header"><a href="#variant.FnDuplicatedParam" class="anchor field"></a><code>FnDuplicatedParam(String,&nbsp;String)</code></h3><div class="docblock"><p>A function definition has duplicated parameters. Wrapped values are the function name and
parameter name.</p>
</div><h3 id="variant.FnMissingBody" class="variant small-section-header"><a href="#variant.FnMissingBody" class="anchor field"></a><code>FnMissingBody(String)</code></h3><div class="docblock"><p>A function definition is missing the body. Wrapped value is the function name.</p>
</div><h3 id="variant.WrongExport" class="variant small-section-header"><a href="#variant.WrongExport" class="anchor field"></a><code>WrongExport</code></h3><div class="docblock"><p>Export statement not at global level.</p>
</div><h3 id="variant.AssignmentToConstant" class="variant small-section-header"><a href="#variant.AssignmentToConstant" class="anchor field"></a><code>AssignmentToConstant(String)</code></h3><div class="docblock"><p>Assignment to an a constant variable. Wrapped value is the constant variable name.</p>
</div><h3 id="variant.AssignmentToInvalidLHS" class="variant small-section-header"><a href="#variant.AssignmentToInvalidLHS" class="anchor field"></a><code>AssignmentToInvalidLHS(String)</code></h3><div class="docblock"><p>Assignment to an inappropriate LHS (left-hand-side) expression.
Wrapped value is the error message (if any).</p>
</div><h3 id="variant.VariableExists" class="variant small-section-header"><a href="#variant.VariableExists" class="anchor field"></a><code>VariableExists(String)</code></h3><div class="docblock"><p>A variable is already defined.</p>
<p>Only appears when variables shadowing is disabled.</p>
</div><h3 id="variant.VariableUndefined" class="variant small-section-header"><a href="#variant.VariableUndefined" class="anchor field"></a><code>VariableUndefined(String)</code></h3><div class="docblock"><p>A variable is not found.</p>
<p>Only appears when strict variables mode is enabled.</p>
</div><h3 id="variant.ModuleUndefined" class="variant small-section-header"><a href="#variant.ModuleUndefined" class="anchor field"></a><code>ModuleUndefined(String)</code></h3><div class="docblock"><p>An imported module is not found.</p>
<p>Only appears when strict variables mode is enabled.</p>
</div><h3 id="variant.ExprTooDeep" class="variant small-section-header"><a href="#variant.ExprTooDeep" class="anchor field"></a><code>ExprTooDeep</code></h3><div class="docblock"><p>Expression exceeding the maximum levels of complexity.</p>
</div><h3 id="variant.LiteralTooLarge" class="variant small-section-header"><a href="#variant.LiteralTooLarge" class="anchor field"></a><code>LiteralTooLarge(String,&nbsp;usize)</code></h3><div class="docblock"><p>Literal exceeding the maximum size. Wrapped values are the data type name and the maximum size.</p>
</div><h3 id="variant.LoopBreak" class="variant small-section-header"><a href="#variant.LoopBreak" class="anchor field"></a><code>LoopBreak</code></h3><div class="docblock"><p>Break statement not inside a loop.</p>
</div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Clone-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-Clone-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Clone for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#method.clone" class="anchor"></a><h4 class="code-header">fn <a class="fnname">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a>Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl has-srclink"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor"></a><h4 class="code-header">const fn <a class="fnname">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-Debug-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Debug for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a class="fnname">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Display-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#179-253">source</a><a href="#impl-Display-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Display for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#180-252">source</a><a href="#method.fmt-1" class="anchor"></a><h4 class="code-header">fn <a class="fnname">fmt</a>(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CLexError%3E-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#255-266">source</a><a href="#impl-From%3CLexError%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl From&lt;<a class="enum" href="enum.LexError.html" title="enum rhai::LexError">LexError</a>&gt; for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#258-265">source</a><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a class="fnname">from</a>(err: <a class="enum" href="enum.LexError.html" title="enum rhai::LexError">LexError</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CParseErrorType%3E-for-Box%3CEvalAltResult%3E" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#309-315">source</a><a href="#impl-From%3CParseErrorType%3E-for-Box%3CEvalAltResult%3E" class="anchor"></a><h3 class="code-header">impl From&lt;<a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>&gt; for Box&lt;<a class="enum" href="plugin/enum.EvalAltResult.html" title="enum rhai::plugin::EvalAltResult">EvalAltResult</a>&gt;</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#312-314">source</a><a href="#method.from-1" class="anchor"></a><h4 class="code-header">fn <a class="fnname">from</a>(err: <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-From%3CParseErrorType%3E-for-EvalAltResult" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#317-323">source</a><a href="#impl-From%3CParseErrorType%3E-for-EvalAltResult" class="anchor"></a><h3 class="code-header">impl From&lt;<a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>&gt; for <a class="enum" href="plugin/enum.EvalAltResult.html" title="enum rhai::plugin::EvalAltResult">EvalAltResult</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#320-322">source</a><a href="#method.from-2" class="anchor"></a><h4 class="code-header">fn <a class="fnname">from</a>(err: <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Hash-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-Hash-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Hash for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#method.hash" class="anchor"></a><h4 class="code-header">fn <a class="fnname">hash</a>&lt;__H:&nbsp;Hasher&gt;(&amp;self, state: &amp;mut __H)</h4></section></summary><div class='docblock'>Feeds this value into the given [<code>Hasher</code>]. <a>Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl has-srclink"><span class="since rightside" title="Stable since Rust version 1.3.0">1.3.0</span><a href="#method.hash_slice" class="anchor"></a><h4 class="code-header">fn <a class="fnname">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: &amp;mut H)<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;H: Hasher,</span></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given [<code>Hasher</code>]. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CParseErrorType%3E-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-PartialEq%3CParseErrorType%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl PartialEq&lt;<a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>&gt; for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#method.eq" class="anchor"></a><h4 class="code-header">fn <a class="fnname">eq</a>(&amp;self, other: &amp;<a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a>) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>. <a>Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl has-srclink"><span class="since rightside" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.ne" class="anchor"></a><h4 class="code-header">const fn <a class="fnname">ne</a>(&amp;self, other: &amp;Rhs) -&gt; bool</h4></section></summary><div class='docblock'>This method tests for <code>!=</code>. The default implementation is almost always
sufficient, and should not be overridden without very good reason. <a>Read more</a></div></details></div></details><section id="impl-Eq-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-Eq-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Eq for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-StructuralEq-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-StructuralEq-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl StructuralEq for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-StructuralPartialEq-for-ParseErrorType" class="impl has-srclink"><a class="srclink rightside" href="../src/rhai/types/parse_error.rs.html#70">source</a><a href="#impl-StructuralPartialEq-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl StructuralPartialEq for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-ParseErrorType" class="impl has-srclink"><a href="#impl-RefUnwindSafe-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl RefUnwindSafe for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-Send-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Send-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Send for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-Sync-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Sync-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Sync for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-Unpin-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Unpin-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl Unpin for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section><section id="impl-UnwindSafe-for-ParseErrorType" class="impl has-srclink"><a href="#impl-UnwindSafe-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl UnwindSafe for <a class="enum" href="enum.ParseErrorType.html" title="enum rhai::ParseErrorType">ParseErrorType</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Any-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; Any for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?Sized,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="plugin/struct.TypeId.html" title="struct rhai::plugin::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Borrow%3CT%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; Borrow&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?Sized,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a class="fnname">borrow</a>(&amp;self) -&gt; &amp;T</h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-BorrowMut%3CT%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; BorrowMut&lt;T&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?Sized,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a class="fnname">borrow_mut</a>(&amp;mut self) -&gt; &amp;mut T</h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-From%3CT%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; From&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span><a href="#method.from-3" class="anchor"></a><h4 class="code-header">fn <a class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-Into%3CU%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; Into&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: From&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code>[From]&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToOwned-for-ParseErrorType" class="impl has-srclink"><a href="#impl-ToOwned-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; ToOwned for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Clone,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Owned" class="anchor"></a><h4 class="code-header">type <a class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl has-srclink"><a href="#method.to_owned" class="anchor"></a><h4 class="code-header">fn <a class="fnname">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a>Read more</a></div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl has-srclink"><a href="#method.clone_into" class="anchor"></a><h4 class="code-header">fn <a class="fnname">clone_into</a>(&amp;self, target: &amp;mut T)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-ToString-for-ParseErrorType" class="impl has-srclink"><a href="#impl-ToString-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T&gt; ToString for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: Display + ?Sized,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl has-srclink"><a href="#method.to_string" class="anchor"></a><h4 class="code-header">default fn <a class="fnname">to_string</a>(&amp;self) -&gt; String</h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a>Read more</a></div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-TryFrom%3CU%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; TryFrom&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: Into&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a class="associatedtype">Error</a> = Infallible</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a class="fnname">try_from</a>(value: U) -&gt; Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-ParseErrorType" class="impl has-srclink"><a href="#impl-TryInto%3CU%3E-for-ParseErrorType" class="anchor"></a><h3 class="code-header">impl&lt;T, U&gt; TryInto&lt;U&gt; for T<span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: TryFrom&lt;T&gt;,</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a class="associatedtype">Error</a> = &lt;U as TryFrom&lt;T&gt;&gt;::Error</h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="since rightside" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a class="fnname">try_into</a>(self) -&gt; Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="rhai" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-nightly (5c8bff74b 2022-10-21)" ></div></body></html>